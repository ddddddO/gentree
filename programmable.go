// Package gtree provides tree-structured output.
package gtree

import (
	"io"
	"sync"

	"github.com/pkg/errors"
)

var (
	// ErrNilNode is returned if the argument *gtree.Node of ExecuteProgrammably function is nill.
	ErrNilNode = errors.New("nil node")
	// ErrNotRoot is returned if the argument *gtree.Node of ExecuteProgrammably function is not root of the tree.
	ErrNotRoot = errors.New("not root node")
)

// ExecuteProgrammably outputs tree to w.
// This function requires node generated by NewRoot function.
func ExecuteProgrammably(w io.Writer, root *Node, optFns ...OptFn) error {
	if root == nil {
		return ErrNilNode
	}
	if !root.isRoot() {
		return ErrNotRoot
	}

	conf, err := newConfig(optFns...)
	if err != nil {
		return err
	}

	tree := newTree(conf.encode, conf.formatLastNode, conf.formatIntermedialNode)
	tree.addRoot(root)
	return tree.grow().expand(w)
}

var (
	programableNodeIdx   int
	programableNodeIdxMu sync.Mutex
)

// NewRoot creates a starting node for building tree.
func NewRoot(text string) *Node {
	programableNodeIdxMu.Lock()
	defer programableNodeIdxMu.Unlock()

	programableNodeIdx++

	return newNode(text, rootHierarchyNum, programableNodeIdx)
}

// Add adds a node and returns an instance of it.
// If a node with the same text already exists in the same hierarchy of the tree, that node will be returned.
func (parent *Node) Add(text string) *Node {
	for _, child := range parent.Children {
		if text == child.Text {
			return child
		}
	}

	programableNodeIdxMu.Lock()
	defer programableNodeIdxMu.Unlock()

	programableNodeIdx++

	current := newNode(text, parent.hierarchy+1, programableNodeIdx)
	current.setParent(parent)
	parent.addChild(current)
	return current
}
